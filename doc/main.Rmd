---
title: "Project on CPU, GGPU, and TPU"
author: "Lixian Chen, Zhanhao Zhang, Jingbin Cao"
date: "4/14/2021"
output: pdf_document
---
# Preparing Required Packages
```{r load libraries, warning=FALSE, message=FALSE, include=FALSE}
packages.used=as.list(
  c(
  "tidyverse",
  "haven",
  "devtools",
  "RColorBrewer",
  "data.table",
  "ggplot2",
  "car",
  "dplyr",
  "psych")
)

check.pkg = function(x){
  if(!require(x, character.only=T)) install.packages(x, 
                                                     character.only=T,
                                                     dependence=T)
}

lapply(packages.used, check.pkg)
library(dplyr)
library(car)
library(tidyverse)
library(haven)
library(devtools)
library(RColorBrewer)
library(data.table)
library(ggplot2)
library(psych)
```


```{r}
data <- read.csv("../data/Runtime.csv")
head(data)
```
We tested three types of processors CPU, GPU, and TPU for three kinds of matrix operation, addition, multiplication, and inversion, with the matrix from size 10 to size 2160. We repeat each test for five times.  
**We measured log10(run-time) for each trial, and we use that as the evaluation of the performances.**

# Simple Plots
Here is the general visualization for the performances of each processor under three matrix operations:
```{r}
ggplot(data = data, aes(x = Processor, y = log10(Runtime))) +
geom_boxplot(aes(fill = MatrixOperation))
```
# Zhanhao Zhang Part I
## Pros & Cons of Each Processor  

When matrix size is the same, is there any processor or operation effects? Or is there any interactive effect?
```{r summary}
df_cpu <- data[data$Processor == "CPU",]
lm(Runtime ~ MatrixSize + as.factor(MatrixOperation), data = df_cpu) %>%
  summary()
df_tpu <- data[data$Processor == "TPU",]
lm(Runtime ~ MatrixSize + as.factor(MatrixOperation), data = df_tpu) %>%
  summary()
df_gpu <- data[data$Processor == "GPU",]
lm(Runtime ~ MatrixSize + as.factor(MatrixOperation), data = df_gpu) %>%
  summary()
```

# Lixian Chen Part I
## Analysis
When the processor is the same, is there any operation and matrix size effect? We want to answer the following question: in each scenario, which processor should we use?

```{r, prepare data}
df <- fread("../data/Runtime.csv", header=TRUE)
attach(df)

MatrixOperation<-factor(MatrixOperation)
Processor<-factor(Processor)



CPUdata <- df %>% filter(Processor=="CPU")
GPUdata <- df %>% filter(Processor=="GPU")
TPUdata <- df %>% filter(Processor=="TPU")

#op=par(mfrow=c(1,3))
interaction.plot(CPUdata$MatrixSize, CPUdata$MatrixOperation, CPUdata$Runtime)
interaction.plot(GPUdata$MatrixSize, GPUdata$MatrixOperation, GPUdata$Runtime)
interaction.plot(TPUdata$MatrixSize, TPUdata$MatrixOperation, TPUdata$Runtime)
#par(op)

library(psych)
describeBy(df$Runtime,group = df$MatrixSize, mat = TRUE) %>%  #create dataframe
  select(MatrixSize=group1, N=n, Mean=mean, SD=sd, Median=median, Min=min, Max=max, 
         Skew=skew, Kurtosis=kurtosis, SEM=se)

#boxplot(Runtime~Processor*MatrixOperation)
#tapply(Runtime,list(Processor, MatrixOperation),mean)
#tapply(Runtime,MatrixOperation,mean)

group_by(df, Processor) %>%
  summarise(
    count = n(),
    mean = mean(Runtime, na.rm = TRUE),
    sd = sd(Runtime, na.rm = TRUE)
  )

group_by(df, MatrixOperation) %>%
  summarise(
    count = n(),
    mean = mean(Runtime, na.rm = TRUE),
    sd = sd(Runtime, na.rm = TRUE)
  )

#detach(data) 

size320data <- df %>% filter(MatrixSize==320)
size640data <- df %>% filter(MatrixSize==640)
size1280data <- df %>% filter(MatrixSize==1280)
size2560data <- df %>% filter(MatrixSize==2560)

boxplot(Runtime~Processor*MatrixOperation, data = size320data, main="At the level of matrix size=320")
tapply(Runtime,list(Processor, MatrixOperation),mean, data = size320data)
boxplot(Runtime~Processor*MatrixOperation, data = size640data, main="At the level of matrix size=640")
tapply(Runtime,list(Processor, MatrixOperation),mean, data = size640data)
boxplot(Runtime~Processor*MatrixOperation, data = size1280data, main="At the level of matrix size=1280")
tapply(Runtime,list(Processor, MatrixOperation),mean, data = size1280data)
boxplot(Runtime~Processor*MatrixOperation, data = size2560data, main="At the level of matrix size=2560")
tapply(Runtime,list(Processor, MatrixOperation),mean, data = size2560data)
# At the level of matrix size=2560, avoid using CPU for inversion and multiplication, because its runtimes 
# are much bigger

#320
fit2<-lm(Runtime~Processor+MatrixOperation, data = size320data)
summary(fit2)
fit1<-lm(Runtime~Processor*MatrixOperation, data = size320data)
summary(fit1)
anova(fit2, fit1)

mod320<-aov(Runtime~Processor*MatrixOperation, data = size320data)
#summary(mod320)
Anova(mod320,type="III")

modF<-lm(Runtime~Processor+MatrixOperation, data = size320data)
modA<-lm(Runtime~Processor, data = size320data)
modB<-lm(Runtime~MatrixOperation, data = size320data)

anova(modA, modF)
anova(modB, modF)

#640
fit2_640<-lm(Runtime~Processor+MatrixOperation, data = size640data)
summary(fit2)
fit1_640<-lm(Runtime~Processor*MatrixOperation, data = size640data)
summary(fit1_640)
anova(fit2_640, fit1_640)

mod640<-aov(Runtime~Processor*MatrixOperation, data = size640data)
Anova(mod640,type="III")


modF<-lm(Runtime~Processor+MatrixOperation, data = size640data)
modA<-lm(Runtime~Processor, data = size640data)
modB<-lm(Runtime~MatrixOperation, data = size640data)

anova(modA, modF)
anova(modB, modF)

#1280
fit2_1280<-lm(Runtime~Processor+MatrixOperation, data = size1280data)
summary(fit2)
fit1_1280<-lm(Runtime~Processor*MatrixOperation, data = size1280data)
summary(fit1_1280)
anova(fit2_1280, fit1_1280)

modF<-lm(Runtime~Processor+MatrixOperation, data = size1280data)
modA<-lm(Runtime~Processor, data = size1280data)
modB<-lm(Runtime~MatrixOperation, data = size1280data)

anova(modA, modF)
anova(modB, modF)

mod1280<-aov(Runtime~Processor*MatrixOperation, data = size1280data)
Anova(mod1280,type="III")

#2560
fit2_2560<-lm(Runtime~Processor+MatrixOperation, data = size2560data)
summary(fit2)
fit1_2560<-lm(Runtime~Processor*MatrixOperation, data = size2560data)
summary(fit1_2560)
anova(fit2_2560, fit1_2560)

mod2560<-aov(Runtime~Processor*MatrixOperation, data = size2560data)
Anova(mod2560,type="III")

modF<-lm(Runtime~Processor+MatrixOperation, data = size2560data)
modA<-lm(Runtime~Processor, data = size2560data)
modB<-lm(Runtime~MatrixOperation, data = size2560data)

anova(modA, modF)
anova(modB, modF)

```


# Zhanhao Zhang Part II
## General Visualization
```{r,echo=FALSE}
for(operation in unique(data$MatrixOperation)){
  p <- data %>%
    filter(MatrixOperation == operation) %>%
    ggplot(aes(x = Processor, y = log10(Runtime))) +
    geom_boxplot(aes(fill = as.factor(MatrixSize))) +
    ggtitle(paste0("Matrix Operation: ", operation)) +
    #facet_wrap( ~ MatrixOperation, scales = "free", nrow = 1) +
    guides(fill=guide_legend(title = "Matrix Size"))
  print(p)
}
```

```{r,echo=FALSE}
for(size in unique(data$MatrixSize)){
  p <- data %>%
    filter(MatrixSize == size) %>%
    ggplot(aes(x = MatrixOperation, y = log10(Runtime))) +
    geom_boxplot(aes(fill = as.factor(Processor))) +
    ggtitle(paste0("Matrix Size: ", size)) +
    #facet_wrap( ~ MatrixOperation, scales = "free", nrow = 1) +
    guides(fill=guide_legend(title = "Processor"))
  print(p)
}
```
```{r, echo = FALSE}
for(operation in unique(data$MatrixOperation)){
  p <- data %>%
    filter(MatrixOperation == operation) %>%
    ggplot(aes(x = as.factor(MatrixSize), y = log10(Runtime))) +
    geom_boxplot(aes(fill = as.factor(Processor))) +
    ggtitle(paste0("Matrix Operation: ", operation)) +
    #facet_wrap( ~ MatrixOperation, scales = "free", nrow = 1) +
    guides(fill=guide_legend(title = "Processor"))
  print(p)
}
```

# Lixian Chen Part II
## Plots
```{r, interaction plots}
#Interaction Plots
op=par(mfrow=c(1,1))
#op=par(mfrow=c(2,1))
interaction.plot(df$MatrixSize, df$MatrixOperation, df$Runtime)
interaction.plot(df$MatrixSize, df$MatrixOperation, log(df$Runtime))
#par(op)


```

